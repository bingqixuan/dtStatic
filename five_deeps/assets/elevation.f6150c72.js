import{aJ as N,J as O,N as S,ny as k,j as B,c3 as C,c0 as D,aO as j,b8 as G,R as H}from"./vendor.d5f590a2.js";const I=N.getLogger("esri.geometry.support.meshUtils.elevation");async function Q(e,a,t){var c;let p;return M(e)||e instanceof O?(p=await(await K(e)).createElevationSampler(a,{demResolution:(c=t==null?void 0:t.demResolution)!=null?c:"finest-contiguous"}),F(p,a,{material:t==null?void 0:t.material})):typeof(t==null?void 0:t.demResolution)=="string"?(I.error("create()","demResolution must be a number when used directly with a sampler"),null):F(e,a,{material:t==null?void 0:t.material,demResolution:t==null?void 0:t.demResolution})}function F(e,a,t){var A,b;const p=C(a.spatialReference),c=((A=t.demResolution)!=null?A:e.demResolution.min)/p,i=Math.round(a.width/c),u=Math.round(a.height/c),o=i+1,y=u+1,m=new Float64Array(o*y*3),w=new Float32Array(o*y*2);let d=0,v=0;const n=new Uint32Array(i*u*2*3);let s=0,l=0;const U=!e.spatialReference.equals(a.spatialReference);R.spatialReference=a.spatialReference;const{xmin:$,ymin:E,height:J,width:q}=a;for(let r=0;r<y;r++){const h=E+J*(r/u);for(let f=0;f<o;f++){const g=$+q*(f/i);if(m[d++]=g,m[d++]=h,U){R.x=g,R.y=h;const x=D(R,e.spatialReference);m[d++]=j(e.elevationAt(x.x,x.y),0)}else m[d++]=j(e.elevationAt(g,h),0);const z=f/i,L=r/u;w[v++]=z,w[v++]=L,r!==u&&f!==i&&(n[l++]=s+1,n[l++]=s+o+1,n[l++]=s+o,n[l++]=s,n[l++]=s+1,n[l++]=s+o),s++}}return new S({vertexAttributes:new k({position:m,uv:w}),components:[new B({faces:n,shading:"smooth",material:(b=t==null?void 0:t.material)!=null?b:null})],spatialReference:a.spatialReference})}async function K(e){return M(e)?e.load():(await e.load(),await G(e.layers.map(a=>a.load())),e)}function M(e){return"type"in e&&(e.type==="elevation"||e.type==="base-elevation")}const R=new H;export{Q as create};
